import numpy as np
import math
import random

#RRT function written by Ethan. Inputs include start point, end point, step size
#which would be like increment length of a tree (distance between points)
# and the obstacle mask including a white background and obstacles in black
#similar to the image handling shown in the main source used as inspiration
#psuedocode includes initializing the tree based on start point and also obstacle
#locations, adding nodes at random, check each new step for collision, find
#the nearest old tree node and connect to the random point, and adding the new
#node to the tree assuming no collision. At the end of the loop we will trace the
#path that got us from start to end. RRT* could be used to find optimized path by 
#checking nodes nearby for shorter path but for the given timeline I will use
#RRT (TBD)
#Sources:
#https://msl.cs.illinois.edu/~lavalle/papers/Lav98c.pdf
#https://github.com/nimRobotics/RRT
#https://graham-clifford.com/rrt-algorithm/#:~:text=usage:%20rrt.py%20%5B%2Dh,planning%20domain%20Output:%20the%20RRT
#https://www.youtube.com/watch?v=OXikozpLFGo

def is_free(x,y,obstacle_mask):
    h,w = obstacle_mask.shape
    if x < 0 or x>=w or y < 0 or y>=h:
        return False
    return obstacle_mask[y,x] > 0

def random_config(obstacle_mask):
    #Source: https://docs.python.org/3/library/random.html
    h,w = obstacle_mask.shape
    while True:
        x = random.randint(0, w-1)
        y = random.randint(0, h-1)
        if is_free(x,y,obstacle_mask):
            return (x,y)
        
def col_check(p1,p2,obstacle_mask, num): #num = number of samples 
    x1,y1 = p1
    x2,y2 = p2

    for i in range (num+1):
        t= i / float(num)
        x = int((x1 + (x2-x1)*t))
        y = int((y1 + (y2-y1)*t))
        #checking collision from current node to next node with is free func
        if not is_free(x,y,obstacle_mask):
            return False
    return True

def dist(p1,p2):
    dist = math.hypot(p1[0]-p2[0], p1[1]-p2[1])
    return dist

def nearest_node(nodes, p_rand):
    #Finds the nearest node based on finding the distance between the random
    #point and every node in nodes
    idx = 0
    distance = float('inf')
    for i,p in enumerate(nodes):
        d = dist(p,p_rand)
        if d < distance:
            distance = d
            idx = i
    return idx

def steer(p_near, p_rand, step_size):
    #logic developed from https://msl.cs.illinois.edu/~lavalle/papers/Lav98c.pdf
    #ie “From the nearest vertex, a new state is generated by taking a small step in the direction of the random sample.”
    #(4) and "The incremental distance is controlled by a parameter delta" basically
    #meaning step size. I framed my logic for "steering" around moving from my nearest 
    #confirmed point in the tree a short distance toward the randomly chosen point so
    #like steering from point A to point B in small steps, this is necessary to avoid
    #obstacles in this use case 
    x_near, y_near = p_near
    x_rand, y_rand = p_rand

    delta_x = x_rand - x_near
    delta_y = y_rand - y_near
    delta = math.hypot(delta_x, delta_y)

    if delta == 0:
        return p_near #if random point has been reached

    if delta <= step_size:
        return (x_rand, y_rand)
    else:
        ratio = step_size / delta
        x_new = int(x_near + delta_x *ratio)
        y_new = int(y_near + delta_y *ratio)
        return (x_new, y_new)

def build_path(nodes, parents, goal_idx):
    path = []
    idx = goal_idx
    while idx != -1:
        path.append(nodes[idx])
        idx = parents[idx]
    path.reverse()
    return np.array(path)


#function builds path of confirmed nodes that will be the returned variable
def rrt(frame, start, end, steps):
    nodes = [start]
    parents = [-1]
    num = 50 #sample of collision along edges
    max_i = 1000 #max iterations in case no path is ever found

    for i in range(max_i):
        if random.random() < 0.1:
            p_rand = end
        else:
            p_rand = random_config(frame)

        #Find nearest node to random
        idx_near = nearest_node(nodes, p_rand)
        p_near = nodes[idx_near]

        #Steer towards the random point from nearest node
        p_new = steer(p_near, p_rand, steps)
        #collision checks
        if not is_free(p_new[0], p_new[1], frame):
            continue
        if not col_check(p_near, p_new, frame, num):
            continue
        #adding node to tree path
        nodes.append(p_new)
        parents.append(idx_near)

        #global reachability check (checking if goal can be reached from tree)
        #with current nodes
        if dist(p_new, end) <= 5 and col_check(p_new, end, frame, num):
            nodes.append(end)
            parents.append(len(nodes)-2)
            path = build_path(nodes,parents,len(nodes)-1)
            return path
    return None

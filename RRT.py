import numpy as np
import math
import random
from robot_kinematics import Robot3R
link = False

#RRT function written by Ethan. Inputs include start point, end point, step size
#which would be like increment length of a tree (distance between points)
# and the obstacle mask including a white background and obstacles in black
#similar to the image handling shown in the main source used as inspiration
#psuedocode includes initializing the tree based on start point and also obstacle
#locations, adding nodes at random, check each new step for collision, find
#the nearest old tree node and connect to the random point, and adding the new
#node to the tree assuming no collision. At the end of the loop we will trace the
#path that got us from start to end. RRT* could be used to find optimized path by 
#checking nodes nearby for shorter path but for the given timeline I will use
#RRT (TBD)
#Sources:
#https://msl.cs.illinois.edu/~lavalle/papers/Lav98c.pdf
#https://github.com/nimRobotics/RRT
#https://graham-clifford.com/rrt-algorithm/#:~:text=usage:%20rrt.py%20%5B%2Dh,planning%20domain%20Output:%20the%20RRT
#https://www.youtube.com/watch?v=OXikozpLFGo

if link:
    def links_col_check(q, robot, frame, samples):
    #Using 3R parameters and robot_kinematics.py to check for obstacle collision
    #checks for link collisions at given joint snapshot q. still need a function
    #that checks for nearby nodes continuously   
        points = robot.forward_kinematics(q[0],q[1],q[2])
        links = [(points[0], points[1]), (points[1], points[2]), (points[2], points[3])]
        for (p1,p2) in links:
            if not col_check(p1,p2, frame, samples):
                return False
        return True

    def cont_links_col_check(q_near, q_new, robot, frame, K, samples):
        #K is number of interpolation steps 
        for i in range(K+1):
            t = i/float(K)
            q_interp = (
                q_near[0] + t*(q_new[0] - q_near[0]),
                q_near[1] + t*(q_new[1] - q_near[1]),
                q_near[2] + t*(q_new[2] - q_near[2]),
            )
            if not links_col_check(q_interp, robot, frame, samples):
                return False
        return True

def calc_total_length(path):
    total_length = 0.0
    for i in range(len(path) - 1):
        x1, y1 = path[i]
        x2, y2 = path[i + 1]
        total_length  = total_length + math.hypot(x2 - x1, y2 - y1)
    return total_length

def is_free(x,y,obstacle_mask):
    h,w = obstacle_mask.shape
    if x < 0 or x>=w or y < 0 or y>=h:
        return False
    return obstacle_mask[y,x] > 0

def random_config(obstacle_mask):
    #Source: https://docs.python.org/3/library/random.html
    h,w = obstacle_mask.shape
    while True:
        x = random.randint(0, w-1)
        y = random.randint(0, h-1)
        if is_free(x,y,obstacle_mask):
            return (x,y)
        
def col_check(p1,p2,obstacle_mask, num): #num = number of samples 
    x1,y1 = p1
    x2,y2 = p2

    for i in range (num+1):
        t= i / float(num)
        x = int((x1 + (x2-x1)*t))
        y = int((y1 + (y2-y1)*t))
        #checking collision from current node to next node with is free func
        if not is_free(x,y,obstacle_mask):
            return False
    return True

def dist(p1,p2):
    dist = math.hypot(p1[0]-p2[0], p1[1]-p2[1])
    return dist

def nearest_node(nodes, p_rand):
    #Finds the nearest node based on finding the distance between the random
    #point and every node in nodes
    idx = 0
    distance = float('inf')
    for i,p in enumerate(nodes):
        d = dist(p,p_rand)
        if d < distance:
            distance = d
            idx = i
    return idx

def steer(p_near, p_rand, step_size):
    #logic developed from https://msl.cs.illinois.edu/~lavalle/papers/Lav98c.pdf
    #ie “From the nearest vertex, a new state is generated by taking a small step in the direction of the random sample.”
    #(4) and "The incremental distance is controlled by a parameter delta" basically
    #meaning step size. I framed my logic for "steering" around moving from my nearest 
    #confirmed point in the tree a short distance toward the randomly chosen point so
    #like steering from point A to point B in small steps, this is necessary to avoid
    #obstacles in this use case 
    x_near, y_near = p_near
    x_rand, y_rand = p_rand

    delta_x = x_rand - x_near
    delta_y = y_rand - y_near
    delta = math.hypot(delta_x, delta_y)

    if delta == 0:
        return p_near #if random point has been reached

    if delta <= step_size:
        return (x_rand, y_rand)
    else:
        ratio = step_size / delta
        x_new = int(x_near + delta_x *ratio)
        y_new = int(y_near + delta_y *ratio)
        return (x_new, y_new)

def build_path(nodes, parents, goal_idx):
    path = []
    idx = goal_idx
    while idx != -1:
        path.append(nodes[idx])
        idx = parents[idx]
    path.reverse()
    return np.array(path)


#function builds path of confirmed nodes that will be the returned variable

def rrt(frame, start, end, steps, robot):
    nodes = [start]
    parents = [-1]
    num = 50 #sample of collision along edges
    max_i = 1e20 #max iterations in case no path is ever found
    link_samples = 20 # num samples of link checked 
    K = 10 #interpolation for link edge collision checks 

    for i in range(max_i):
        if random.random() < 0.1:
            p_rand = end
        else:
            p_rand = random_config(frame)

        #Find nearest node to random
        idx_near = nearest_node(nodes, p_rand)
        p_near = nodes[idx_near]

        #Steer towards the random point from nearest node
        p_new = steer(p_near, p_rand, steps)
        #collision checks
        if not is_free(p_new[0], p_new[1], frame):
            continue
        if not col_check(p_near, p_new, frame, num):
            continue
        if link:
            q_near = robot.inverse_kinematics(p_near[0], p_near[1])
            q_new = robot.inverse_kinematics(p_new[0], p_new[1])
            #getting joint vars to be used in collision checks
            if q_near is None or q_new is None:
                continue #if unreachable
            if not links_col_check(q_new, robot, frame, link_samples):
                continue
            if not cont_links_col_check(q_near, q_new, robot, frame, K, link_samples):
                continue
        #after all collision checks now we can add new node to our tree path
        #adding node to tree path
        nodes.append(p_new)
        parents.append(idx_near)

        #global reachability check (checking if goal can be reached from tree)
        #with current nodes
        if dist(p_new, end) <= 5 and col_check(p_new, end, frame, num):
            if link:
                q_goal = robot.inverse_kinematics(end[0],end[1])
                if q_goal is None:
                    continue
                if not links_col_check(q_new, robot, frame, link_samples):
                    continue
                if not cont_links_col_check(q_near, q_new, robot, frame, K, link_samples):
                    continue
                #last check for goal reachability with no collision
            nodes.append(end)
            parents.append(len(nodes)-2)
            path = build_path(nodes,parents,len(nodes)-1)
            tree_dist = calc_total_length(path)
            return path, tree_dist
    return None
